火车站卖票

争用情况

争用情况是一种特定的情况：
两个或更多的线程或进程读或写一些共享数据，而最终结果取决于这些线程是如何被调度计时的。争用情况可能会导致不可预见的结果和隐蔽的程序错误。

比如变量 i 原先为 0（int i = 0），对其做两次 i++, 期望结果为 2。
在单线程的情况下，顺序执行，结果总是为 2，符合预期。
但要是两个线程同时执行，那么结果有可能为 1。

int i = 0;

i++;
i++;

i0 = i; // i0=0
i1 = i0 + 1; // i1=0+1
i = i1; // i=1

i2 = i; // i2=1
i3 = i2 + 1; // i3=1+1
i = i3; // i=2



i0 = i; // i0=0
                          i2 = i; // i2=0
i1 = i0 + 1; // i1=0+1
                          i3 = i2 + 1; // i3=0+1
i = i1; // i=1
                          i = i3; // i=1







synchronized 是 JVM 提供的一种排队机制。
多个线程需要同时访问同一个对象，则线程进入这个对象的等待池(wait pool)形成队列，等待前面的线程使用完毕后，下一个线程再使用。






setFoo(getFoo() + 1);

...
 private int foo;
 public synchronized int getFoo() { return foo; } 
 public synchronized void setFoo(int f) { foo = f; }
 
 
 synchronized 的语义确实保证了一次只有一个线程可以访问被保护的区段，但同时还包括同步线程在主存内互相作用的规则。理解 Java 内存模型（JMM）的一个好方法就是把各个线程想像成运行在相互分离的处理器上，所有的处理器存取同一块主存空间，每个处理器有自己的缓存，但这些缓存可能并不总和主存同步。在缺少同步的情况下，JMM 会允许两个线程在同一个内存地址上看到不同的值。而当用一个管程（锁）进行同步的时候，一旦申请加了锁，JMM 就会马上要求该缓存失效，然后在它被释放前对它进行刷新（把修改过的内存位置写回主存）。不难看出为什么同步会对程序的性能影响这么大，频繁地刷新缓存代 价会很大。
 
 
 争用：维护队列，排队时间
 
 线程同步机制（协调）排队
 
 共享资源（变量）的读写，排队
 
 
 要使您的程序线程安全，首先必须确定哪些数据将在线程间共享。如果正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。
 
 
 乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止
 
 volatile只能保证变量对各个线程的可见性，但不能保证原子性。
 
 Java高级-线程同步机制实现
 https://my.oschina.net/xianggao/blog/88293
 
 非阻塞同步算法与CAS(Compare and Swap)无锁算法
 http://www.cnblogs.com/Mainz/p/3546347.html
 
 非阻塞算法简介
 https://www.ibm.com/developerworks/cn/java/j-jtp04186/index.html
 
 不共享有时是最好的
 https://www.ibm.com/developerworks/cn/java/j-threads/index3.html
 
 关于Java并发编程的总结和思考
 http://blog.csdn.net/jackfrued/article/details/44499227
 
 
 上面几种锁都是JVM自己内部实现，当我们执行synchronized同步块的时候jvm会根据启用的锁和当前线程的争用情况，决定如何执行同步操作；

在所有的锁都启用的情况下线程进入临界区时会先去获取偏向锁，如果已经存在偏向锁了，则会尝试获取轻量级锁，如果以上两种都失败，则启用自旋锁，如果自旋也没有获取到锁，则使用重量级锁，没有获取到锁的线程阻塞挂起，直到持有锁的线程执行完同步块唤醒他们；

偏向锁是在无锁争用的情况下使用的，也就是同步开在当前线程没有执行完之前，没有其它线程会执行该同步快，一旦有了第二个线程的争用，偏向锁就会升级为轻量级锁，一点有两个以上线程争用，就会升级为重量级锁；

如果线程争用激烈，那么应该禁用偏向锁。

java 中的锁 -- 偏向锁、轻量级锁、自旋锁、重量级锁
http://blog.csdn.net/zqz_zqz/article/details/70233767