REST 是一种 web 服务组织架构，为建立扩展性良好的分布式系统而生。

## 1
* * *
## 四层

《[Rest In Practice](https://www.amazon.com/gp/product/0596805829)》书中，将 REST 架构的实现程度，分为四个层次。

### 1.1
* * *
### Level 0: The Swamp of POX

　**传输**：使用 HTTP 作为传输方式，比如通过网络将这篇文章发送到你的面前，为第一个层次。

SOAP、XML-RPC 等都属于这个层次。

### 1.2
* * *
### Level 1: Resources

　**资源**：引入了资源的概念。和处于第一个层次的 RPC 想比较：

- RPC 是面向功能的架构，设计之初首先需要考虑的是提供怎样的功能；
- REST 是面向资源的架构，所以设计之初首要考虑的是有哪些资源可供操作。

### 1.3
* * *
### Level 2: HTTP Verbs

　**动作**：这个层次和第二个层次相比，除了 GET，POST，还使用了 HTTP 的更多方法，比如 DELETE，PATCH 等，进一步统一了操作接口。

### 1.4
* * *
### Level 3: Hypermedia Controls

　**HATEOAS**：到第四层才算是真正的 REST 架构。这个层次解决的是 service discoverablility 和 self-documenting。　

　我们回到 REST 的定义：为建立扩展性良好的分布式系统而生。而这个世界上，规模最大的分布式系统，就是互联网本身。

　互联网的一切都是资源。当我们想获取一个资源，比如购买一个东西时。我们只需知道一个互联网的入口，打开搜索引擎，找到购物网站，按网站的指引挑选商品，下单，支付。在这里互联网就如同一个状态机，告诉用户当前状态，以及下一步可以操作的东西，比如链接、按钮等等。引导我们完成每一步操作，直至获取到想要的资源。

　HATEOAS 想做到的正是如此。REST 客户端只需要知道一个服务入口，就可以获取到和这个入口相关的，所有可用资源列表，以及对某种资源可以进行的操作。

- 每个资源都拥有一个资源标识，可以用来唯一地标明该资源。
- REST 系统中返回的信息，需描述资源自身的信息。例如 MIME 类型，是否可以被缓存等。
- REST 系统中返回的信息，需描述资源自身的处理方式。例如添加资源，更新资源的的操作链接，而不需要额外的文档进行说明。

```xml
例如：
GET /account/12345 HTTP/1.1
Host: bank.io
Accept: application/xml

返回：
<account>
  <account_number>12345</account_number>
  <balance currency="usd">100.00</balance>
  <link rel="存款" href="https://bank.io/account/12345/deposit" />
  <link rel="取款" href="https://bank.io/account/12345/withdraw" />
  <link rel="转账" href="https://bank.io/account/12345/transfer" />
</account>

而当账户透支时，可操作链接就只剩存款了：
<account>
  <account_number>12345</account_number>
  <balance currency="usd">-100.00</balance>
  <link rel="存款" href="https://bank.io/account/12345/deposit" />
</account>
```

　实例如：[GitHub API](https://api.github.com/)


## 2
* * *
## 资源和状态

REST 密切相关的两个名词：资源和状态

- 资源：操作的实体对象
- 状态：每次对资源进行添加、删除或修改的时候，资源就从一个状态转移到另外一个状态。



## 1
* * *
## 主资源与子资源

REST采用以资源为中心的描述方法（如：将商品放入购物车，购物车被抽象为资源，放入动作被视为对资源的更新）

主资源与子资源：如果一个资源是主资源，那么其可以被不同的资源实例包含引用而不会产生歧义。而如果一个资源是子资源，那么被不同的资源实例引用可能会产生歧义

判断我们为REST服务所定义的资源是否合理的方法：

  　　1. 我们需要考虑对该资源的CRUD是否有意义，从而验证资源的定义是否合理。就以刚刚说到的列表的分页显示为例，我们可以想象一下如何对分页进行添加和删除？一旦删除了该分页，那么属于该分页中的各个商品也应该被删除么？而且删除了分页X的数据后，原本X + 1分页的数据将展示在X分页中。很显然，将商品的分页定义为资源并不合理。

  　　2. 我们需要检查资源是否需要除CRUD之外的动词来操作。该方法用来检查资源中是否还有子资源没有被抽象。如果该资源还需要额外的动词，那么我们就需要考虑这些操作到底引起了什么样的状态变化，进而抽象出该资源的子资源。

  　　3. 我们还需要检查这些资源是否是被整体使用，创建和删除。该方法用来探测是否一个子资源应该是一个主资源。如果在删除一个资源的时候，其子资源还可以被其它资源重用，那么该子资源实际上具有较高的重用性，应该是一个主资源。





## 1
* * *
## 资源识别

通常我们需要分析达成某个目标所需要使用的业务逻辑，并为业务逻辑的执行提供一系列运行接口。比如将商品放入购物车，提交订单等。这一系列动作组合在一起，就可以组成完成目标所需要执行的业务逻辑。

而在 REST 服务中，我们提供的接口是一系列资源，而业务逻辑需要通过对资源的操作来完成。也就是说，REST 服务中的API将不再以执行了什么动作为中心，而是以资源为中心。对资源的通用操作即 CRUD。

以上面所举的“将商品放入购物车”这个操作为例。在一个 REST 系统中，购物车被抽象为一个资源，而“将商品放入购物车”就是对购物车这个资源的更新：更新购物车，以使特定商品包含在购物车内。

这种以资源为中心的架构，别于很多 Web 服务那样以动作为中心。带来系统设计步骤的改变：对于业务逻辑，首先关注的不再是完成它所需的各种动作，而是完成它所需要的各种资源。

## 1
* * *
## 如何抽象资源
在这里，我们就以“提交订单”作为示例来展示如何抽象资源。

1. 在“提交订单”这个动作中，订单是宾语。因此对于该业务逻辑，其将作为一个资源存在。
2. 除此之外，在订单中还需要包含一系列信息，例如订单中所包含的商品，订单所属人等。一旦这些都可以被该REST系统中的其它资源使用，那么它们也将成为独立的资源。
3. 但是有时候，一个动作可能并不存在着它所操作的宾语。在这种情况下，我们就需要考虑该动作产生或消除了哪个实体，或者哪个实体的状态发生了变化。这个发生了变化的实体实际上就是一种资源。例如对于登陆这一行为，其实际上在服务端创建了一个会话实例。该会话实例中则包含了登陆IP，登陆时间，以及登陆时所用的凭证等。再比如对于用户更改密码这种行为，其所操作的资源就是用户资料。

在抽象资源的过程中，我们需要按照自顶向下的方式，即首先辨识出系统中的最主要资源，然后再辨识这些主要资源的子资源，并依次进行迭代。

## 1
* * *
## 主资源和子资源

对主资源的抽取主要通过分析业务逻辑来完成。在得到功能需求以后，我们首先要分析这些业务逻辑所操作的宾语。这些宾语可能有两种情况：主资源或者其它资源的子资源。
1. 主资源实际上就是能够独立存在的一系列资源。
2. 子资源则需要依附于主资源之上才能表达实际的意义。同时各个子资源也可能拥有自身的子资源。

## 1
* * *
## 如何判断一个资源是否是子资源

1. 看它是否能独立地表示其具体含义。
   例如对于一个商品，其名称，价格，简介等属性可以清晰地描述该商品到底是什么，到底如何销售。因此这些商品实际上是一个主资源。但是每种商品所支持的邮递服务需要是一个子资源：一个商品可以支持多种邮递服务。这些邮递服务根据派送距离等需要不同的价格，也提供了不同的邮递速度。由于这些邮递服务与商家和邮递服务公司所达成的服务价格有关，并且会由于商品重量的变化而变化，因此这些邮递服务并不能为其它商家所提供的邮递服务作为参考，因此其应该作为该商品的一个子资源。

　　或者也可以说，如果一个资源是主资源，那么其可以被不同的资源实例包含引用而不会产生歧义。而如果一个资源是子资源，那么被不同的资源实例引用可能会产生歧义。


#### 如何判断我们为 REST 服务所定义的资源是否合理：

1. 首先，我们需要考虑对该资源的 CRUD 是否有意义，从而验证资源的定义是否合理。
   就以刚刚说到的列表的分页显示为例，我们可以想象一下如何对分页进行添加和删除？一旦删除了该分页，那么属于该分页中的各个商品也应该被删除么？而且删除了分页X的数据后，原本X + 1分页的数据将展示在X分页中。很显然，将商品的分页定义为资源并不合理。

2. 其次，我们需要检查资源是否需要除CRUD之外的动词来操作。该方法用来检查资源中是否还有子资源没有被抽象。如果该资源还需要额外的动词，那么我们就需要考虑这些操作到底引起了什么样的状态变化，进而抽象出该资源的子资源。
3. 除此之外，我们还需要检查这些资源是否是被整体使用，创建和删除。该方法用来探测是否一个子资源应该是一个主资源。如果在删除一个资源的时候，其子资源还可以被其它资源重用，那么该子资源实际上具有较高的重用性，应该是一个主资源。

#### 表现形式

一种资源可能有多种不同的表现形式。例如商品，在使用列表展示时，只需要展示名称、简单描述、价格以及一张商品的照片。而在详情页面，则需要显示更详尽的信息，如商品的重量，商品所在地等等。
除此之外，资源列表也有可能拥有多种不同的表现形式。举例来说，如果属于某个分类的商品太多，需要分页显示，那么这种分页是否也应该是一种资源？
答案是，这些分页并不是一种资源，而其只是资源列表的一种表现方式。在每页所包含商品数量，排序规则等条件发生变化的时候，该资源列表中所包含的各个商品也会发生变化。



Level 3

REST简介 http://www.cnblogs.com/loveis715/p/4669091.html
理解RESTful架构 http://www.ruanyifeng.com/blog/2011/09/restful.html
RESTful API 设计指南 http://www.ruanyifeng.com/blog/2014/05/restful_api.html
Representational State Transfer (REST) http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
