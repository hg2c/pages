Jonas Bonér是Lightbend的创始人兼CTO，他主持了大会的开场演讲“blah, blah... microservices...blah, blah”。他在演讲中表示，他相信传统的架构与平台已经过时，一体性的架构往往倾向于完成过多的功能，而无法对业务领域进行非常有效地建模。虽然微服务中的“微”可能并不是一个最恰当的词语，但其隐含的单一职责（这一思想来自于受Unix启发的SRP哲学）概念确实是非常有价值的。开发者所设计的系统也应当保持“灵活性与可定位能力”以“拥抱网络”。由于所有基于微服务的应用事实上都会被部署为分布式系统，因此坚持“猜测、致歉及补偿”这种沟通与行动的迭代是一种非常有价值的模式。此外，Saga模式体现出了非凡的价值，它能够正确地处理在实际应用中经常出现的最终一致性。

1、经典事务
所谓的经典事务一般是指在传统的关系数据库中应用的事务处理方法。它要求事务的ACID特性。实践证明，由于不同的特点，使得工作流系统不能完全照搬数据库事务处理的方法。数据库与工作流中的事务管理既有相同点，又有不同点。数据库中的事务和工作流系统中的事务都旨在保护数据的一致性，以及在错误和故障时，如何保证数据的可靠性。 但也有很多不同之处，例如：(1) 经典事务模型主要是针对数据库中的事务，以数据为中心构成了它的主要特点。这样的语义不能直接应用到工作流中。因为，工作流中的活动可能是事务性的，也可能具有非事务性。工作流中的事务和数据库或事务处理系统中的事务面向的对象不一样，相比而言，工作流中的事务面对的主要对象本身更具复杂性。(2) 组成数据库中的事务的操作一般执行时间都相对较短，但工作流中的事务活动通常执行时间长，涉及到很多对象，有复杂的控制逻辑。长活动作为单独的ACID事务执行会严重拖延其他高优先级的短事务的执行。(3)All-or-nothing对于工作流活动显得太严格而且代价很高。工作流事务需要避免这个问题，提供灵活的事务处理。(4) 在经典事务模型中，恢复单元是事务，每一个事务都有一个预先定义的语义集合，该集合与事务处理系统一致，工作流中的恢复模型更为复杂，恢复过程不仅要恢复工作流系统的状态，而且要使得过程能继续推进，保持与整个组织过程的一致。
如果我们将整个工作流过程看作一个经典事务，将会产生一系列的问题，例如：(1) 较长的持续时间增加了执行过程出现差错的可能性。一旦出现差错，根据原子性的要求，在此之前所做的大量工作都会丢失。(2) 隔离性要求使得不同的事务之间不能进行消息或者控制的交换，然而对于工作流中的协同活动而言，在不同的事务之间存在这样或者那样的依赖关系是很正常的现象；(3) 此外加锁的并发控制机制极大地降低了长事务的吞吐率，而且限制了不同用户之间实时的数据交换，使得协作丧失了基础。(4) 对于协作流程特别是同步协作，用户需要感知到对方的存在，但在传统的数据库应用中,用户独自使用数据库，感觉不到其他用户的存在。

2、高级事务
由于前面提到的原因，所以人们开始对工作流事务处理方面进行深入研究。一个工作流的执行，一般来说都要花费很长的时间，并且很多情况下，都需要人工干预才能完成。例如，在商品的订购与发售这样的流程上消耗的时间更加不可预测。所谓长事务（Long-living Transaction）是需要长时间运行的事务，如果我们将长事务作为一个原子事务来处理，就会使系统性能变差，而且长事务的原子性可能会让系统长期占用资源，同时增加了事务取消和死锁的概率。为了解决这些问题，人们以经典事务为基础，又提出了许多高级事务模型。


b) Sagas
Saga模型的解决方案：如果将长事务分成一系列的小事务，每个小事务都有自己的ACID属性，则这个长事务就叫做saga事务。当所有的小事务都进行了提交后，整个saga事务才算提交。假如saga事务执行了一部分小事务就取消了，那么必须对已经提交了小事务进行补偿。
Saga模型的基本原理：假设Saga事务为Ts，将Ts分解成一系列小事务T1，T2，T3…Tn，每一个小事务对应着一个补偿事务C1，C2，C3…Cn。系统有两种执行路线，一是顺序执行了T1，T2，T3….Tn后，这时Ts提交。二是顺序执行T1，T2，T3…Ti,Ci,Ci-1,…C3,C2,C1后取消，这时Ts取消。
 Saga模型放松了对事务操作的分离性的要求，增加了事务间的并发性。
